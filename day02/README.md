# Day 2: [Corruption Checksum][day]

## Part 1
``` text
The spreadsheet consists of rows of apparently-random numbers. To make sure
the recovery process is on the right track, they need you to calculate the
spreadsheet's checksum. For each row, determine the difference between the
largest value and the smallest value; the checksum is the sum of all of
these differences.

For example, given the following spreadsheet:

5 1 9 5
7 5 3
2 4 6 8

  - The first row's largest and smallest values are 9 and 1, and their
    difference is 8.
  - The second row's largest and smallest values are 7 and 3, and their
    difference is 4.
  - The third row's difference is 6.

  In this example, the spreadsheet's checksum would be 8 + 4 + 6 = 18.
```

So far, this year's challenges could be called "Advent of Map-Reduce". Part one was pretty simple, after some mildly yucky text splitting, the checksum was a one-line reduce function. The fun part was getting to use the [ES6 Spread Operator][spread] to call `Math.min` and `Math.max` with each item in the row as a sequential argument. Made for a very clean, almost pythonic, solution:

``` js
arr.reduce((total, row) => total + Math.max(...row) - Math.min(...row), 0);
```

I do kind of hate the dangling `0` before the end of the reduce call. Very easy to overlook. 

# Part 2

``` text
It sounds like the goal is to find the only two numbers in each row where
one evenly divides the other - that is, where the result of the division
operation is a whole number. They would like you to find those numbers on
each line, divide them, and add up each line's result.

For example, given the following spreadsheet:

5 9 2 8
9 4 7 3
3 8 6 5

  - In the first row, the only two numbers that evenly divide are 8 and 2;
    the result of this division is 4.
  - In the second row, the two numbers are 9 and 3; the result is 3.
  - In the third row, the result is 2.

In this example, the sum of the results would be 4 + 3 + 2 = 9.

```

This was a little trickier. I had a couple initial observations and questions going in:

* The divisor will always be smaller than half the dividend
* Which is faster? Modulo and conditional division or one division with a `Math.trunc` comparison
* Is the dividend prime? How expensive are [primality tests][miller-rabin]? [Premature?][all evil]

My first thought was that reducing the array would be wasteful since, presumably the result would be found somewhere in the middle. After going back and forth between nested loops and a reduce, nested loops turned out faster by 25-40%. Though again, these loops are so ludicrously fast it's barely worth considering. 

The nested loops also let me try a language feature I'd never used before; breaking out of [labeled blocks][label]. Though, in thinking about this a bit later, I wonder if I should get over my "only return once" prejudice and use a second return to short-circuit the loops instead of a  labeled break.

Using the modulo operator in the conditional turned out to be just slightly faster than using `Math.trunc`, and it smells a lot better to me. I didn't bother with primality tests. 

[day]: http://adventofcode.com/2017/day/2
[spread]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator
[miller-rabin]: https://www.npmjs.com/package/miller-rabin
[all evil]: https://en.wikipedia.org/wiki/Program_optimization#cite_ref-autogenerated268_4-0
[for of]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of
[label]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label
